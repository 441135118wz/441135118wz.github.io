<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ori的个人博客</title>
  
  <subtitle>热爱生活，热爱学习</subtitle>
  <link href="https://441135118wz.github.io/atom.xml" rel="self"/>
  
  <link href="https://441135118wz.github.io/"/>
  <updated>2025-01-31T05:51:05.034Z</updated>
  <id>https://441135118wz.github.io/</id>
  
  <author>
    <name>President</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树状数组模板</title>
    <link href="https://441135118wz.github.io/2025/01/31/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF/"/>
    <id>https://441135118wz.github.io/2025/01/31/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF/</id>
    <published>2025-01-31T05:45:19.000Z</published>
    <updated>2025-01-31T05:51:05.034Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;T&gt; a;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> n_ = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>(n_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = n_;</span><br><span class="line">        a.<span class="built_in">assign</span>(n, T&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> T &amp;v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x + <span class="number">1</span>; i &lt;= n; i += i &amp; -i) &#123;</span><br><span class="line">            a[i - <span class="number">1</span>] = a[i - <span class="number">1</span>] + v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        T ans&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= i &amp; -i) &#123;</span><br><span class="line">            ans = ans + a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeSum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">const</span> T &amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>; T cur&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> &lt;&lt; <span class="built_in">int</span>(std::<span class="built_in">log2</span>(n)); i; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + i &lt;= n &amp;&amp; cur + a[x + i - <span class="number">1</span>] &lt;= k) &#123;</span><br><span class="line">                x += i; cur = cur + a[x - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="fenwick-树树状数组模板解析与用法"><code>Fenwick</code>树（树状数组）模板解析与用法</h2><h3 id="模板结构"><strong>模板结构</strong></h3><p>这个 <code>Fenwick</code> 结构体是 <strong>树状数组（Fenwick Tree，或Binary Indexed Tree, BIT）</strong>，它用于<strong>高效维护前缀和</strong>，支持单点修改和前缀求和操作。</p><hr /><h3 id="成员变量"><strong>成员变量</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;           </span><br><span class="line">std::vector&lt;T&gt; a;  </span><br></pre></td></tr></table></figure><ul><li><code>n</code>：数组的大小。</li><li><code>a</code>：存储树状数组的 <strong>核心数据结构</strong>，用<code>std::vector&lt;T&gt;</code> 维护。</li></ul><hr /><h3 id="构造函数"><strong>构造函数</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Fenwick</span>(<span class="type">int</span> n_ = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">init</span>(n_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>作用：初始化 <code>Fenwick</code> 树，默认为空(<code>n = 0</code>)。</li><li><code>init(n_)</code>：调用初始化函数。</li></ul><hr /><h3 id="函数解析"><strong>函数解析</strong></h3><h4 id="initint-n_初始化"><strong>1.<code>init(int n_)</code>：初始化</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_)</span> </span>&#123;</span><br><span class="line">    n = n_;</span><br><span class="line">    a.<span class="built_in">assign</span>(n, T&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>作用：初始化 <code>Fenwick</code> 树大小<code>n</code>，并将所有元素清空（设为 <code>T&#123;&#125;</code>，即类型<code>T</code> 的默认值）。</li><li><code>a.assign(n, T&#123;&#125;)</code>：创建大小为 <code>n</code>的数组，所有元素初始化为 <code>0</code>（或 <code>T&#123;&#125;</code>）。</li></ul><hr /><h4 id="addint-x-const-t-v单点更新"><strong>2.<code>add(int x, const T &amp;v)</code>：单点更新</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> T &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x + <span class="number">1</span>; i &lt;= n; i += i &amp; -i) &#123;</span><br><span class="line">        a[i - <span class="number">1</span>] = a[i - <span class="number">1</span>] + v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>作用：<strong>在索引 <code>x</code> 位置加上<code>v</code></strong>，维护树状数组结构。</li><li><strong>核心原理</strong>：<ul><li><code>i = x + 1</code>：树状数组通常从 <code>1</code> 开始存储，因此<code>x</code> 需要 <code>+1</code>（但 <code>a</code> 仍从<code>0</code> 开始）。</li><li><code>i += i &amp; -i</code>：跳转到下一个受影响的节点。</li><li><code>a[i - 1] += v</code>：累加 <code>v</code> 到对应位置。</li></ul></li></ul><hr /><h4 id="sumint-x求前缀和"><strong>3.<code>sum(int x)</code>：求前缀和</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    T ans&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= i &amp; -i) &#123;</span><br><span class="line">        ans = ans + a[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>作用：<strong>计算前缀 <code>[0, x-1]</code>的区间和</strong>。</li><li><strong>核心原理</strong>：<ul><li><code>i = x</code>：直接从 <code>x</code> 开始往上累加贡献值。</li><li><code>i -= i &amp; -i</code>：跳转到前一个影响的节点。</li><li><code>ans += a[i - 1]</code>：累加贡献值。</li></ul></li></ul><hr /><h4 id="rangesumint-l-int-r求区间和"><strong>4.<code>rangeSum(int l, int r)</code>：求区间和</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">rangeSum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>作用：<strong>求 <code>[l, r-1]</code> 区间的和</strong>。</li><li><strong>计算方式</strong>：<ul><li><code>sum(r)</code> 计算 <code>[0, r-1]</code> 的前缀和。</li><li><code>sum(l)</code> 计算 <code>[0, l-1]</code> 的前缀和。</li><li><strong>区间和</strong> <code>= sum(r) - sum(l)</code>。</li></ul></li></ul><hr /><h4 id="selectconst-t-k二分查找满足前缀和-k-的最大索引"><strong>5.<code>select(const T &amp;k)</code>：二分查找满足前缀和 <code>≤ k</code>的最大索引</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">const</span> T &amp;k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    T cur&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> &lt;&lt; <span class="built_in">int</span>(std::<span class="built_in">log2</span>(n)); i; i /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x + i &lt;= n &amp;&amp; cur + a[x + i - <span class="number">1</span>] &lt;= k) &#123;</span><br><span class="line">            x += i;</span><br><span class="line">            cur = cur + a[x - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>作用：<strong>找到最大的 <code>x</code>，使得<code>sum(x) ≤ k</code></strong>。</li><li><strong>核心思路</strong>：<ul><li>使用 <strong>倍增思想</strong>，从最高位开始尝试加<code>i</code>，找到最大的 <code>x</code>，使得<code>sum(x) ≤ k</code>。</li><li><code>i = 1 &lt;&lt; int(std::log2(n))</code>：找最高位的<code>1</code>。</li><li><code>x + i &lt;= n &amp;&amp; cur + a[x + i - 1] &lt;= k</code>：<ul><li><strong>如果当前累加不会超过 <code>k</code></strong>，就把<code>x</code> 更新到 <code>x + i</code>。</li><li><code>cur = cur + a[x - 1]</code>：更新累加值。</li></ul></li></ul></li></ul><hr /><h3 id="用法示例"><strong>用法示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Fenwick&lt;<span class="type">int</span>&gt; <span class="title">fen</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 创建大小为 10 的树状数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在索引 2, 4, 6 位置增加值</span></span><br><span class="line">    fen.<span class="built_in">add</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    fen.<span class="built_in">add</span>(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">    fen.<span class="built_in">add</span>(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算前缀和</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sum(6) = &quot;</span> &lt;&lt; fen.<span class="built_in">sum</span>(<span class="number">6</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// sum(6) = 5 + 3 + 7 = 15</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sum(3) = &quot;</span> &lt;&lt; fen.<span class="built_in">sum</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// sum(3) = 5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rangeSum(2, 6) = &quot;</span> &lt;&lt; fen.<span class="built_in">rangeSum</span>(<span class="number">2</span>, <span class="number">6</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// sum(6) - sum(2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择满足前缀和 &lt;= 8 的最大索引</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;select(8) = &quot;</span> &lt;&lt; fen.<span class="built_in">select</span>(<span class="number">8</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h3 id="总结"><strong>总结</strong></h3><table><thead><tr><th><strong>函数</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>init(n_)</code></td><td>初始化树状数组，大小为 <code>n_</code></td></tr><tr><td><code>add(x, v)</code></td><td>在索引 <code>x</code> 位置加上 <code>v</code></td></tr><tr><td><code>sum(x)</code></td><td>计算 <code>[0, x-1]</code> 的前缀和</td></tr><tr><td><code>rangeSum(l, r)</code></td><td>计算 <code>[l, r-1]</code> 的区间和</td></tr><tr><td><code>select(k)</code></td><td>找到最大的 <code>x</code>，使得 <code>sum(x) ≤ k</code></td></tr></tbody></table><p>这个 Fenwick 树适用于：</p><ol type="1"><li><strong>动态维护数组前缀和</strong>（支持修改）</li><li><strong>高效计算区间和</strong>（<code>O(log n)</code> 复杂度）</li><li><strong>二分查找前缀和</strong>（<code>select(k)</code>）</li></ol><p>适合用于 <strong>动态前缀和查询、区间查询、逆序对计算</strong>等场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    
    <category term="模板" scheme="https://441135118wz.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>现阶段训练方向</title>
    <link href="https://441135118wz.github.io/2025/01/29/%E7%8E%B0%E9%98%B6%E6%AE%B5%E8%AE%AD%E7%BB%83%E6%96%B9%E5%90%91/"/>
    <id>https://441135118wz.github.io/2025/01/29/%E7%8E%B0%E9%98%B6%E6%AE%B5%E8%AE%AD%E7%BB%83%E6%96%B9%E5%90%91/</id>
    <published>2025-01-29T14:52:41.000Z</published>
    <updated>2025-01-29T15:03:01.751Z</updated>
    
    <content type="html"><![CDATA[<p>1.27的2024年除夕前最后一场div1+div2成功打上了1600分，正式进入蓝名的阶段，接下来是我对新的一年的布局规划和训练目标。</p><span id="more"></span><p>以前感觉1600分很难打，现在感觉就是把水题快点过掉就能上，但对自身的认知更加清晰，算法部分是相当的弱，树上的题很多想的出来但是实现有困难而且不会调，虽然去年上半年也是这个情况，省赛那道题也是一样，只是之前的基础实在薄弱，我花了将近一年的时间把基础打好，说出来也是自行惭愧，但是去年确实很摆。但至少能证明我的基础比以前好了许多，30分钟内abc应该是没有问题，剩下的1个小时，如果会做的话，时间应该是够写代码的，所以现阶段已经是能力不足的时期，对2000分左右难度的题的算法了解不够或是早就遗忘，所以我打算在寒假阶段，尽量多利用整块的时间，来学习新的算法，多学习树、图、数据结构等相对较繁琐的知识点。今天先不定具体算法，感觉树上的问题需要锻炼相关问题的思维，而并不是简单的学一些算法就有用，就像前几天的牛客，我会合并但是换根的时候就宕机推式子推了半天没有结果。需要多做相关题目，最近就去板刷cf树的题试试，先试15道吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1.27的2024年除夕前最后一场div1+div2成功打上了1600分，正式进入蓝名的阶段，接下来是我对新的一年的布局规划和训练目标。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>abc390</title>
    <link href="https://441135118wz.github.io/2025/01/26/abc390/"/>
    <id>https://441135118wz.github.io/2025/01/26/abc390/</id>
    <published>2025-01-25T18:11:33.000Z</published>
    <updated>2025-01-25T18:16:45.639Z</updated>
    
    <content type="html"><![CDATA[<p>10多分钟写完了abc，d的优化不够到位被卡，ddl上又多一条dfs优化了。</p><p>这次的e倒是很简单，看到min 取max，第一反应就是二分，于是就是对三种不同的分别背包然后二分，由于他数据范围小所以暴力n2也能过，但是二分应该是最好的算法。</p><p>暴力的思想需要学习。</p><p>xor的性质也不是很了解，需要学习线性基。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;10多分钟写完了abc，d的优化不够到位被卡，ddl上又多一条dfs优化了。&lt;/p&gt;
&lt;p&gt;这次的e倒是很简单，看到min 取max
，第一反应就是二分，于是就是对三种不同的分别背包然后二分，由于他数据范围小所以暴力n2也能过，但是二分应该是最好的算法。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>树形dp学习笔记</title>
    <link href="https://441135118wz.github.io/2025/01/24/%E6%A0%91%E5%BD%A2dp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://441135118wz.github.io/2025/01/24/%E6%A0%91%E5%BD%A2dp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-01-24T08:04:09.000Z</published>
    <updated>2025-01-25T18:16:27.713Z</updated>
    
    <content type="html"><![CDATA[<p>牛客寒假训练营i题是个树形dp，又想到济南的铜牌题也是树形dp，感觉有必要研究一下。</p><p>update at 1.26 2:00</p><p>研究了差不多一天半，差不多会了，先算子树合并的贡献，再算具体的贡献。后面有空细细记录一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;牛客寒假训练营i题是个树形dp，又想到济南的铜牌题也是树形dp，感觉有必要研究一下。&lt;/p&gt;
&lt;p&gt;update at 1.26 2:00&lt;/p&gt;
&lt;p&gt;研究了差不多一天半，差不多会了，先算子树合并的贡献，再算具体的贡献。后面有空细细记录一下。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>st表模板</title>
    <link href="https://441135118wz.github.io/2025/01/24/st%E8%A1%A8%E6%A8%A1%E6%9D%BF/"/>
    <id>https://441135118wz.github.io/2025/01/24/st%E8%A1%A8%E6%A8%A1%E6%9D%BF/</id>
    <published>2025-01-24T07:33:18.000Z</published>
    <updated>2025-01-24T07:42:07.436Z</updated>
    
    <content type="html"><![CDATA[<p>简洁好用的st表板子 适用条件：数组不变如果需要修改，还是写线段树吧</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ST</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;T&gt;&gt; st;</span><br><span class="line">    <span class="built_in">ST</span>(<span class="type">int</span> n = <span class="number">0</span>, vector&lt;T&gt; &amp;a = &#123;&#125;) : <span class="built_in">n</span>(n)&#123;</span><br><span class="line">        st = <span class="built_in">vector</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;T&gt;(<span class="number">22</span> + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">build</span>(n, a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">get</span><span class="params">(<span class="type">const</span> T &amp;x, <span class="type">const</span> T &amp;y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n, vector&lt;T&gt; &amp;a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            st[i][<span class="number">0</span>] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>, t = <span class="number">2</span>; t &lt;= n; j++, t &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i + t - <span class="number">1</span> &gt; n) <span class="keyword">break</span>;</span><br><span class="line">                st[i][j] = <span class="built_in">get</span>(st[i][j - <span class="number">1</span>], st[i + (t &gt;&gt; <span class="number">1</span>)][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">find</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>(st[l][t], st[r - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ST&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(n,f)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">cout &lt;&lt;st.<span class="built_in">find</span>(l,r) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简洁好用的st表板子 适用条件：数组不变
如果需要修改，还是写线段树吧&lt;/p&gt;</summary>
    
    
    
    
    <category term="模板" scheme="https://441135118wz.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>1.24随笔</title>
    <link href="https://441135118wz.github.io/2025/01/24/1.24%E9%9A%8F%E7%AC%94/"/>
    <id>https://441135118wz.github.io/2025/01/24/1.24%E9%9A%8F%E7%AC%94/</id>
    <published>2025-01-23T18:23:12.000Z</published>
    <updated>2025-01-23T18:26:27.152Z</updated>
    
    <content type="html"><![CDATA[<p>找回这个荒废了一年多的博客并设置好了，看看效果，后面的做题记录就写在这里了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;找回这个荒废了一年多的博客并设置好了，看看效果，后面的做题记录就写在这里了。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="日记" scheme="https://441135118wz.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>01-Trie的原理与应用</title>
    <link href="https://441135118wz.github.io/2023/11/15/01-trie%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://441135118wz.github.io/2023/11/15/01-trie%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2023-11-15T06:08:15.000Z</published>
    <updated>2025-01-23T18:32:01.194Z</updated>
    
    <content type="html"><![CDATA[<p><ahref="https://www.luogu.com.cn/problem/CF1895D">CF1895D</a>这道题用到了01-Trie，那就再来复习一下01-Trie。</p><span id="more"></span><h2 id="简介">简介</h2><p><strong>01-Trie</strong> 中文名 <strong>是01字典树</strong>，是一种特殊的字典树，它的字符集只有<spanclass="math inline">\(\{0,1\}\)</span>，主要用来解决一些异或问题。</p><h2 id="背景">背景</h2><p>所以，我们先来看一下<strong>字典树</strong>。</p><p><img src="https://oi-wiki.org/string/images/trie1.png" /></p><h3 id="应用">应用：</h3><h5 id="检索字符串">1.检索字符串</h5><p>字典树最基础的应用——查找一个字符串是否在「字典」中出现过。（ps:最容易理解）</p><h5 id="ac-自动机">2.AC 自动机</h5><p>trie 是 <a href="https://oi-wiki.org/string/ac-automaton/">AC自动机</a> 的一部分。（先不学）</p><h5 id="维护异或极值">3.维护异或极值</h5><p>将数的二进制表示看做一个字符串，就可以建出字符集为<spanclass="math inline">\(\{0,1\}\)</span>的 Trie 树。</p><h5 id="维护异或和">4.维护异或和</h5><p>01-trie 是指字符集为<span class="math inline">\(\{0,1\}\)</span>的trie。01-trie 可以用来维护一些数字的异或和，支持修改（删除 +重新插入），和全局加一（即：让其所维护所有数值递增<code>1</code>，本质上是一种特殊的修改操作）。</p><p>如果要维护异或和，需要按值从低位到高位建立 trie。</p><p>重点来研究一下3两点。</p><h2 id="正文">正文</h2><h4 id="问题引入">问题引入</h4><p>给一个长为 <span class="math inline">\(n\)</span>的数列，要求一个<span class="math inline">\(a_i,a_j\)</span>，使得<spanclass="math inline">\(a_i\ xor\ a_j\)</span>最大。</p><h4 id="题解">题解</h4><p>重点是解决已知<spanclass="math inline">\(a_i\)</span>，如何找到异或和最大的<spanclass="math inline">\(a_j\)</span></p><p>我们先建一个01-Trie</p><figure><imgsrc="https://pic4.zhimg.com/80/v2-96108ac067f921e737eefa60a7b42f9f_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>现在对于上面问题，我们贪心地解决即可。如果我们要找与给定数异或<strong>最大</strong>的数，就尽可能走与该数当前位<strong>不同</strong>的路径。反之则尽可能走与当前位<strong>相同</strong>的路径。</p><p>这样可以在$n $的复杂度下求出极值。</p><h2 id="总结">总结</h2><p>思想就是这些，代码难度也一般。</p><p>在今后遇到异或求极值的时候或是求字符串前缀、是否出现等问题的时候，trie是一个很不错的选择。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a
href=&quot;https://www.luogu.com.cn/problem/CF1895D&quot;&gt;CF1895D&lt;/a&gt;这道题用到了01-Trie，那就再来复习一下01-Trie。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://441135118wz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>推白色相簿2有感</title>
    <link href="https://441135118wz.github.io/2023/11/10/%E6%8E%A8%E7%99%BD%E8%89%B2%E7%9B%B8%E7%B0%BF2%E6%9C%89%E6%84%9F/"/>
    <id>https://441135118wz.github.io/2023/11/10/%E6%8E%A8%E7%99%BD%E8%89%B2%E7%9B%B8%E7%B0%BF2%E6%9C%89%E6%84%9F/</id>
    <published>2023-11-10T10:47:03.000Z</published>
    <updated>2023-11-10T11:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>一月份下载的游戏，到了11月10号才推完，断断续续快一年，才推完这部被称为神作的gal。</p><p><strong>真正好的作品，是能够打动人心的。</strong></p><span id="more"></span><p>​在推的过程中，不知道为什么，总是感觉到希望伴随着失望。序章没有选项，只能由着“我“选择小木曾雪菜，但是却念念不忘和纱，却在最后快要分开的时候才表露自己的心意。对于序章的结局，我感觉很难以接受，因为剧情里的每个人都是痛苦的。在推的过程中，我时常会想，为什么看似每一步都是最优解，而最终的结局确实这样的痛苦。要比喻一下的话，就很像贪心和dp的区别。我总是会很疑惑，为何雪菜什么都知道，却还是这样爱着春希。即使，中间那被冷落的3年。只有到了最后，我才知道，是她觉得从和纱的手中抢走春希的行为，是最大的罪孽，她此后受到的冷落，都被她理解为了是处罚。而春希，我觉得是最幸福却是最不幸的，他爱着和纱，却不得不选择雪菜，而最后，他的选择是一直喜欢和纱，爱着雪菜。我对于白月光的执着，让我在选项中都向着和纱，但是最后的结局还是有一些遗憾：雪菜和春希走到了最后，和纱也重新振作了起来。看起来还不错的结局，却是经历了多少的挫折和痛苦、猜疑才达成的。三个人永远在一起的世界，也许是永远达不成的，但是，却是每个人为之努力的方向。这样纯真的感情也许只有在这种虚拟的作品中才能见到，但是我们会为之感动，会尽可能的用自己的感性的判断来让他们达成尽可能好的结局。这才是gal的魅力吧。</p><p>​和纱之所以努力的练钢琴，有2个原因，一个是爱春希，一个是爱母亲，作品中爱的力量驱使着和纱化悲痛为力量，一直朝前，努力称为下一个天才冬马。</p><p>​玩完之后的彷徨，一是因为我对这剧情的感慨，二也是我对感情这种复杂东西的新认知，在之前，我会认为只要努力的付出，像春希一样的思考问题并去付诸行动，便能成功。这部作品，确实对于我没谈过恋爱的人生有指导意义。</p><p>​上次这么深思还是玩完eden的时候，也emo了好久，可能是我比较感性，也可能是我的阅历太少了。</p><p>以上，便是我推完白色相簿2的一些感受。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一月份下载的游戏，到了11月10号才推完，断断续续快一年，才推完这部被称为神作的gal。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;真正好的作品，是能够打动人心的。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="颓" scheme="https://441135118wz.github.io/tags/%E9%A2%93/"/>
    
  </entry>
  
  <entry>
    <title>拓展欧几里得</title>
    <link href="https://441135118wz.github.io/2023/10/18/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    <id>https://441135118wz.github.io/2023/10/18/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</id>
    <published>2023-10-18T09:43:53.000Z</published>
    <updated>2025-01-24T06:11:29.992Z</updated>
    
    <content type="html"><![CDATA[<p>一个晚上的成果。 <span id="more"></span></p><h1 id="背景">背景</h1><h3 id="贝祖定理">贝祖定理：</h3><p>如果 <span class="math inline">\(a\)</span>、<spanclass="math inline">\(b\)</span> 是整数，那么一定存在整数 <spanclass="math inline">\(x\)</span> ， <spanclass="math inline">\(y\)</span> 使得 <spanclass="math inline">\(ax+by=gcd(a,b)\)</span> 。</p><h3 id="证明">证明：</h3><ol type="1"><li>若任何一个等于 <span class="math inline">\(0\)</span> ，则 <spanclass="math inline">\(gcd(a,b)=a\)</span> ，这时定理显然成立</li><li>若 <span class="math inline">\(a,b\)</span> 不等于0. 由于 <spanclass="math inline">\(gcd(a,b)=gcd(a,-b)\)</span> , 不妨设 <spanclass="math inline">\(a,b\)</span> 都大于0， <spanclass="math inline">\(a\ge b,gcd(a,b)=d.\)</span> 对 <spanclass="math inline">\(ax+by=d\)</span> ，两边同时除以 <spanclass="math inline">\(d\)</span> ,可得 <spanclass="math inline">\(a_1x+b_1y=1\)</span> ,其中 <spanclass="math inline">\((a_1,b_1)=1\)</span> . 转证 <spanclass="math inline">\(a_1x+b_1y=1\)</span> .我们先回顾一下辗转相除法是怎么做的，由 <spanclass="math inline">\(gcd(a,b)\longrightarrow gcd(b,a modb)\longrightarrow...\)</span> 我们把模出来的数据叫做 <spanclass="math inline">\(r\)</span> 于是有： <span class="math display">\[gcd(a_1,b_1)=gcd(b_1,r_1)=gcd(r_1,r_2)=...=gcd(r_{n-1},r_n)=1\]</span></li></ol><p>把辗转相除法中的运算展开，做成带余数的除法，得 <spanclass="math display">\[\begin{equation}\begin{aligned}a_1=q_1b_1+r_1(0\le r_1 &lt;b_1) \\b_1=q_2r_1+r_2(0\le r_2 &lt;r_1) \\r_1=q_3r_2+r_3 (0\le r_3 &lt;b_2)\\... \\r_{n-3}=q_{n-1}r_{n-2}+r_{n-1} \\r_{n-2}=q_nr_{n-1}+r_n\\r_{n-1}=q_{n+1}r_{n}\end{aligned}\end{equation}\]</span> 不妨令辗转相除法在除到互质的时候退出则<spanclass="math inline">\(r_n=1\)</span> （<spanclass="math inline">\(q\)</span>被换成了<spanclass="math inline">\(x\)</span>,为了符合最终形式） <spanclass="math display">\[r_{n-2}=x_nr_{n-1}+1\]</span> 即 <span class="math display">\[1=r_{n-2}-x_nr_{n-1}\]</span> 由倒数第三个式子<spanclass="math inline">\(r_{n-1}=r_{n-3}-x_{n-1}r_{n-2}\)</span>代入上式，得<span class="math display">\[1=(1+x_nx_{n-1})r_{n-2}-x_nr_{n-3}\]</span> 然后用同样的方法用它上面的等式逐个的消去<spanclass="math inline">\(r_{n-2},...,r_1\)</span>,</p><p>可证得<spanclass="math inline">\(1=a_1x+b_1y\)</span>.这样等于是一般式中<spanclass="math inline">\(d=1\)</span>的情况</p><h3 id="欧几里得算法">欧几里得算法</h3><p>即辗转相除法，它的代码非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辗转相除法，求两个数的最大公因数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓展欧几里得算法">拓展欧几里得算法</h1><p>扩展欧几里得算法用来解决这样一个问题：给定两个非零的整数<spanclass="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>，求一组整数解<spanclass="math inline">\((x，y)\)</span>使得<spanclass="math inline">\(ax+by = gcd(a,b)\)</span>成立，其中<spanclass="math inline">\(gcd(a,b)\)</span>表示<spanclass="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>的最大公约数。（其中我们通过前面的贝祖定理可知解一定存在）</p><p>回忆我们知道的欧几里得算法，它总是把<spanclass="math inline">\(gcd(a,b)\)</span>转化为求解 <spanclass="math inline">\(gcd(b,a\%b)\)</span> ，而当<spanclass="math inline">\(b\)</span>变为<spanclass="math inline">\(0\)</span>时返回<spanclass="math inline">\(a\)</span>，此时的<spanclass="math inline">\(a\)</span>就等于<spanclass="math inline">\(gcd\)</span>。也就是说，欧几里得算法结束时变量<spanclass="math inline">\(a\)</span>中存放的是<spanclass="math inline">\(gcd\)</span>，变量<spanclass="math inline">\(b\)</span>中存放的是<spanclass="math inline">\(0\)</span>，因此此时显然有<spanclass="math inline">\(a × 1 + b × 0 = g c d\)</span>成立，此时有<spanclass="math inline">\(x=1\)</span>、<spanclass="math inline">\(y=0\)</span>成立。</p><p>我们不妨利用上面的欧几里得算法的过程来计算<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>。目前已知的是递归边界成立时为<spanclass="math inline">\(x=1\)</span>、<spanclass="math inline">\(y=0\)</span>，需要想办法反推出最初始的<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>。</p><p>对比等号左右两边可以马上得到下面的递推公式： <spanclass="math display">\[\begin{cases}x_1=y_2\\y_1=x_2-(a/b)y_2\end{cases}\]</span> 由此可以通过<span class="math inline">\(x_2\)</span>和<spanclass="math inline">\(y_2\)</span>来进行反推出<spanclass="math inline">\(x_1\)</span>和<spanclass="math inline">\(y_1\)</span>了。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exGcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span>   <span class="comment">//x和y使用引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">exGcd</span>(b, a%b, x, y);    <span class="comment">//递归计算exGcd（b,a%b）</span></span><br><span class="line">    <span class="type">int</span> temp = x;             <span class="comment">//存放x的值</span></span><br><span class="line">    x = y;</span><br><span class="line">    y = temp - (a/b)*y;       <span class="comment">//更新y = x(old) - a/b*y(old)</span></span><br><span class="line">    <span class="keyword">return</span> g;                 <span class="comment">//g是gcd</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于这里我们使用了引用，因此当 <spanclass="math inline">\(exGcd\)</span> 函数结束时 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 就是所求的解。</p><p>显然，在得到这样一组解之后，就可以通过下面的式子得到全部解（其中<span class="math inline">\(K\)</span> 为任意整数）： <spanclass="math display">\[\begin{cases}x^{&#39;}=x+\frac {b}{gcd}\times K\\y^{&#39;}=y-\frac{a}{gcd}\times K\end{cases}\]</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个晚上的成果。</summary>
    
    
    
    
  </entry>
  
</feed>
