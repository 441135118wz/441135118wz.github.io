{"meta":{"title":"ori的个人博客","subtitle":"热爱生活，热爱学习","description":"但求无愧于心","author":"President","url":"https://441135118wz.github.io","root":"/"},"pages":[{"title":"about","date":"2023-10-19T04:15:44.000Z","updated":"2023-10-19T16:05:36.000Z","comments":true,"path":"about/index.html","permalink":"https://441135118wz.github.io/about/index.html","excerpt":"","text":"记录我的日常"}],"posts":[{"title":"树形dp学习笔记","slug":"树形dp学习笔记","date":"2025-01-24T08:04:09.000Z","updated":"2025-01-25T18:10:34.062Z","comments":true,"path":"2025/01/24/树形dp学习笔记/","permalink":"https://441135118wz.github.io/2025/01/24/%E6%A0%91%E5%BD%A2dp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"牛客寒假训练营i题是个树形dp，又想到济南的铜牌题也是树形dp，感觉有必要研究一下。 update at 1.26 2:00 研究了差不多一天半，差不多会了，先算子树合并的贡献，再算具体的贡献。后面有空细细记录一下。","categories":[],"tags":[]},{"title":"st表模板","slug":"st表模板","date":"2025-01-24T07:33:18.000Z","updated":"2025-01-24T07:42:07.436Z","comments":true,"path":"2025/01/24/st表模板/","permalink":"https://441135118wz.github.io/2025/01/24/st%E8%A1%A8%E6%A8%A1%E6%9D%BF/","excerpt":"简洁好用的st表板子 适用条件：数组不变 如果需要修改，还是写线段树吧","text":"简洁好用的st表板子 适用条件：数组不变 如果需要修改，还是写线段树吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt;class ST&#123;public: const int n; vector&lt;vector&lt;T&gt;&gt; st; ST(int n = 0, vector&lt;T&gt; &amp;a = &#123;&#125;) : n(n)&#123; st = vector(n + 1, vector&lt;T&gt;(22 + 1)); build(n, a); &#125; inline T get(const T &amp;x, const T &amp;y)&#123; return max(x, y); &#125; void build(int n, vector&lt;T&gt; &amp;a)&#123; for(int i = 1; i &lt;= n; i++)&#123; st[i][0] = a[i]; &#125; for(int j = 1, t = 2; t &lt;= n; j++, t &lt;&lt;= 1)&#123; for(int i = 1; i &lt;= n; i++)&#123; if(i + t - 1 &gt; n) break; st[i][j] = get(st[i][j - 1], st[i + (t &gt;&gt; 1)][j - 1]); &#125; &#125; &#125; inline T find(int l, int r)&#123; int t = log(r - l + 1) / log(2); return get(st[l][t], st[r - (1 &lt;&lt; t) + 1][t]); &#125;&#125;;int main() &#123; int n,q; cin &gt;&gt; n &gt;&gt; q; vector&lt;int&gt; f(n + 1); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; f[i]; &#125; ST&lt;int&gt; st(n,f); while (q--) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt;st.find(l,r) &lt;&lt; endl; &#125;&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"https://441135118wz.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"1.24随笔","slug":"1.24随笔","date":"2025-01-23T18:23:12.000Z","updated":"2025-01-23T18:26:27.152Z","comments":true,"path":"2025/01/24/1.24随笔/","permalink":"https://441135118wz.github.io/2025/01/24/1.24%E9%9A%8F%E7%AC%94/","excerpt":"","text":"找回这个荒废了一年多的博客并设置好了，看看效果，后面的做题记录就写在这里了。","categories":[],"tags":[{"name":"日记","slug":"日记","permalink":"https://441135118wz.github.io/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"01-Trie的原理与应用","slug":"01-trie的原理与应用","date":"2023-11-15T06:08:15.000Z","updated":"2025-01-23T18:32:01.194Z","comments":true,"path":"2023/11/15/01-trie的原理与应用/","permalink":"https://441135118wz.github.io/2023/11/15/01-trie%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/","excerpt":"CF1895D这道题用到了01-Trie，那就再来复习一下01-Trie。","text":"CF1895D这道题用到了01-Trie，那就再来复习一下01-Trie。 简介 01-Trie 中文名 是01字典树 ，是一种特殊的字典树，它的字符集只有\\(\\{0,1\\}\\)，主要用来解决一些异或问题。 背景 所以，我们先来看一下字典树。 应用： 1.检索字符串 字典树最基础的应用——查找一个字符串是否在「字典」中出现过。（ps:最容易理解） 2.AC 自动机 trie 是 AC 自动机 的一部分。（先不学） 3.维护异或极值 将数的二进制表示看做一个字符串，就可以建出字符集为\\(\\{0,1\\}\\)的 Trie 树。 4.维护异或和 01-trie 是指字符集为\\(\\{0,1\\}\\)的 trie。01-trie 可以用来维护一些数字的异或和，支持修改（删除 + 重新插入），和全局加一（即：让其所维护所有数值递增 1，本质上是一种特殊的修改操作）。 如果要维护异或和，需要按值从低位到高位建立 trie。 重点来研究一下3两点。 正文 问题引入 给一个长为 \\(n\\) 的数列，要求一个\\(a_i,a_j\\)，使得\\(a_i\\ xor\\ a_j\\)最大。 题解 重点是解决已知\\(a_i\\)，如何找到异或和最大的\\(a_j\\) 我们先建一个01-Trie img 现在对于上面问题，我们贪心地解决即可。如果我们要找与给定数异或最大的数，就尽可能走与该数当前位不同的路径。反之则尽可能走与当前位相同的路径。 这样可以在$n $的复杂度下求出极值。 总结 思想就是这些，代码难度也一般。 在今后遇到异或求极值的时候或是求字符串前缀、是否出现等问题的时候，trie是一个很不错的选择。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://441135118wz.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"推白色相簿2有感","slug":"推白色相簿2有感","date":"2023-11-10T10:47:03.000Z","updated":"2023-11-10T11:41:36.000Z","comments":true,"path":"2023/11/10/推白色相簿2有感/","permalink":"https://441135118wz.github.io/2023/11/10/%E6%8E%A8%E7%99%BD%E8%89%B2%E7%9B%B8%E7%B0%BF2%E6%9C%89%E6%84%9F/","excerpt":"一月份下载的游戏，到了11月10号才推完，断断续续快一年，才推完这部被称为神作的gal。 真正好的作品，是能够打动人心的。","text":"一月份下载的游戏，到了11月10号才推完，断断续续快一年，才推完这部被称为神作的gal。 真正好的作品，是能够打动人心的。 ​ 在推的过程中，不知道为什么，总是感觉到希望伴随着失望。序章没有选项，只能由着“我“选择小木曾雪菜，但是却念念不忘和纱，却在最后快要分开的时候才表露自己的心意。对于序章的结局，我感觉很难以接受，因为剧情里的每个人都是痛苦的。在推的过程中，我时常会想，为什么看似每一步都是最优解，而最终的结局确实这样的痛苦。要比喻一下的话，就很像贪心和dp的区别。我总是会很疑惑，为何雪菜什么都知道，却还是这样爱着春希。即使，中间那被冷落的3年。只有到了最后，我才知道，是她觉得从和纱的手中抢走春希的行为，是最大的罪孽，她此后受到的冷落，都被她理解为了是处罚。而春希，我觉得是最幸福却是最不幸的，他爱着和纱，却不得不选择雪菜，而最后，他的选择是一直喜欢和纱，爱着雪菜。我对于白月光的执着，让我在选项中都向着和纱，但是最后的结局还是有一些遗憾：雪菜和春希走到了最后，和纱也重新振作了起来。看起来还不错的结局，却是经历了多少的挫折和痛苦、猜疑才达成的。三个人永远在一起的世界，也许是永远达不成的，但是，却是每个人为之努力的方向。这样纯真的感情也许只有在这种虚拟的作品中才能见到，但是我们会为之感动，会尽可能的用自己的感性的判断来让他们达成尽可能好的结局。这才是gal的魅力吧。 ​ 和纱之所以努力的练钢琴，有2个原因，一个是爱春希，一个是爱母亲，作品中爱的力量驱使着和纱化悲痛为力量，一直朝前，努力称为下一个天才冬马。 ​ 玩完之后的彷徨，一是因为我对这剧情的感慨，二也是我对感情这种复杂东西的新认知，在之前，我会认为只要努力的付出，像春希一样的思考问题并去付诸行动，便能成功。这部作品，确实对于我没谈过恋爱的人生有指导意义。 ​ 上次这么深思还是玩完eden的时候，也emo了好久，可能是我比较感性，也可能是我的阅历太少了。 以上，便是我推完白色相簿2的一些感受。","categories":[],"tags":[{"name":"颓","slug":"颓","permalink":"https://441135118wz.github.io/tags/%E9%A2%93/"}]},{"title":"拓展欧几里得","slug":"拓展欧几里得","date":"2023-10-18T09:43:53.000Z","updated":"2025-01-24T06:11:29.992Z","comments":true,"path":"2023/10/18/拓展欧几里得/","permalink":"https://441135118wz.github.io/2023/10/18/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"一个晚上的成果。","text":"一个晚上的成果。 背景 贝祖定理： 如果 \\(a\\)、\\(b\\) 是整数，那么一定存在整数 \\(x\\) ， \\(y\\) 使得 \\(ax+by=gcd(a,b)\\) 。 证明： 若任何一个等于 \\(0\\) ，则 \\(gcd(a,b)=a\\) ，这时定理显然成立 若 \\(a,b\\) 不等于0. 由于 \\(gcd(a,b)=gcd(a,-b)\\) , 不妨设 \\(a,b\\) 都大于0， \\(a\\ge b,gcd(a,b)=d.\\) 对 \\(ax+by=d\\) ，两边同时除以 \\(d\\) ,可得 \\(a_1x+b_1y=1\\) ,其中 \\((a_1,b_1)=1\\) . 转证 \\(a_1x+b_1y=1\\) . 我们先回顾一下辗转相除法是怎么做的，由 \\(gcd(a,b)\\longrightarrow gcd(b,a mod b)\\longrightarrow...\\) 我们把模出来的数据叫做 \\(r\\) 于是有： \\[ gcd(a_1,b_1)=gcd(b_1,r_1)=gcd(r_1,r_2)=...=gcd(r_{n-1},r_n)=1 \\] 把辗转相除法中的运算展开，做成带余数的除法，得 \\[ \\begin{equation} \\begin{aligned} a_1=q_1b_1+r_1(0\\le r_1 &lt;b_1) \\\\ b_1=q_2r_1+r_2(0\\le r_2 &lt;r_1) \\\\ r_1=q_3r_2+r_3 (0\\le r_3 &lt;b_2)\\\\ ... \\\\ r_{n-3}=q_{n-1}r_{n-2}+r_{n-1} \\\\ r_{n-2}=q_nr_{n-1}+r_n\\\\ r_{n-1}=q_{n+1}r_{n} \\end{aligned} \\end{equation} \\] 不妨令辗转相除法在除到互质的时候退出则\\(r_n=1\\) （\\(q\\)被换成了\\(x\\),为了符合最终形式） \\[ r_{n-2}=x_nr_{n-1}+1 \\] 即 \\[ 1=r_{n-2}-x_nr_{n-1} \\] 由倒数第三个式子\\(r_{n-1}=r_{n-3}-x_{n-1}r_{n-2}\\)代入上式，得 \\[ 1=(1+x_nx_{n-1})r_{n-2}-x_nr_{n-3} \\] 然后用同样的方法用它上面的等式逐个的消去\\(r_{n-2},...,r_1\\), 可证得\\(1=a_1x+b_1y\\).这样等于是一般式中\\(d=1\\)的情况 欧几里得算法 即辗转相除法，它的代码非常简单： 12345678//辗转相除法，求两个数的最大公因数int gcd(int a, int b)&#123; if (b == 0) return a; else return gcd(b, a%b);&#125; 拓展欧几里得算法 扩展欧几里得算法用来解决这样一个问题：给定两个非零的整数\\(a\\)和\\(b\\)，求一组整数解\\((x，y)\\)使得\\(ax+by = gcd(a,b)\\)成立，其中\\(gcd(a,b)\\)表示\\(a\\)和\\(b\\)的最大公约数。（其中我们通过前面的贝祖定理可知解一定存在） 回忆我们知道的欧几里得算法，它总是把\\(gcd(a,b)\\)转化为求解 \\(gcd(b,a\\%b)\\) ，而当\\(b\\)变为\\(0\\)时返回\\(a\\)，此时的\\(a\\)就等于\\(gcd\\)。也就是说，欧几里得算法结束时变量\\(a\\)中存放的是\\(gcd\\)，变量\\(b\\)中存放的是\\(0\\)，因此此时显然有\\(a × 1 + b × 0 = g c d\\)成立，此时有\\(x=1\\)、\\(y=0\\)成立。 我们不妨利用上面的欧几里得算法的过程来计算\\(x\\)和\\(y\\)。目前已知的是递归边界成立时为\\(x=1\\)、\\(y=0\\)，需要想办法反推出最初始的\\(x\\)和\\(y\\)。 对比等号左右两边可以马上得到下面的递推公式： \\[ \\begin{cases}x_1=y_2\\\\y_1=x_2-(a/b)y_2\\end{cases} \\] 由此可以通过\\(x_2\\)和\\(y_2\\)来进行反推出\\(x_1\\)和\\(y_1\\)了。代码如下： 123456789101112131415int exGcd(int a, int b, int &amp;x, int &amp;y) //x和y使用引用&#123; if(b == 0) &#123; x = 1; y = 0; return a; &#125; int g = exGcd(b, a%b, x, y); //递归计算exGcd（b,a%b） int temp = x; //存放x的值 x = y; y = temp - (a/b)*y; //更新y = x(old) - a/b*y(old) return g; //g是gcd&#125; 由于这里我们使用了引用，因此当 \\(exGcd\\) 函数结束时 \\(x\\) 和 \\(y\\) 就是所求的解。 显然，在得到这样一组解之后，就可以通过下面的式子得到全部解（其中 \\(K\\) 为任意整数）： \\[ \\begin{cases}x^{&#39;}=x+\\frac {b}{gcd}\\times K\\\\y^{&#39;}=y-\\frac {a}{gcd}\\times K\\end{cases} \\]","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"https://441135118wz.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"日记","slug":"日记","permalink":"https://441135118wz.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"name":"算法","slug":"算法","permalink":"https://441135118wz.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"颓","slug":"颓","permalink":"https://441135118wz.github.io/tags/%E9%A2%93/"}]}