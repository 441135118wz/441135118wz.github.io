{"meta":{"title":"ori的个人博客","subtitle":"热爱生活，热爱学习","description":"但求无愧于心","author":"President","url":"https://441135118wz.github.io","root":"/"},"pages":[{"title":"about","date":"2023-10-19T04:15:44.000Z","updated":"2023-10-19T16:05:36.000Z","comments":true,"path":"about/index.html","permalink":"https://441135118wz.github.io/about/index.html","excerpt":"","text":"记录我的日常"}],"posts":[{"title":"树状数组模板","slug":"树状数组模板","date":"2025-01-31T05:45:19.000Z","updated":"2025-01-31T14:12:41.796Z","comments":true,"path":"2025/01/31/树状数组模板/","permalink":"https://441135118wz.github.io/2025/01/31/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF/","excerpt":"template类","text":"template类 12345678910111213141516171819202122232425262728293031323334353637383940template &lt;typename T&gt;struct Fenwick&#123; int n; std::vector&lt;T&gt; a; Fenwick(int n_ = 0) &#123; init(n_); &#125; void init(int n_) &#123; n = n_; a.assign(n, T&#123;&#125;); &#125; void add(int x, const T &amp;v) &#123; for (int i = x + 1; i &lt;= n; i += i &amp; -i) &#123; a[i - 1] = a[i - 1] + v; &#125; &#125; T sum(int x) &#123; T ans&#123;&#125;; for (int i = x; i &gt; 0; i -= i &amp; -i) &#123; ans = ans + a[i - 1]; &#125; return ans; &#125; T rangeSum(int l, int r) &#123; return sum(r) - sum(l); &#125; int select(const T &amp;k) &#123; int x = 0; T cur&#123;&#125;; for (int i = 1 &lt;&lt; int(std::log2(n)); i; i /= 2) &#123; if (x + i &lt;= n &amp;&amp; cur + a[x + i - 1] &lt;= k) &#123; x += i; cur = cur + a[x - 1]; &#125; &#125; return x; &#125;&#125;; Fenwick 树（树状数组）模板解析与用法 模板结构 这个 Fenwick 结构体是 树状数组（Fenwick Tree，或 Binary Indexed Tree, BIT），它用于 高效维护前缀和，支持单点修改和前缀求和操作。 成员变量 12int n; std::vector&lt;T&gt; a; n：数组的大小。 a：存储树状数组的 核心数据结构，用 std::vector&lt;T&gt; 维护。 构造函数 123Fenwick(int n_ = 0) &#123; init(n_);&#125; 作用：初始化 Fenwick 树，默认为空 (n = 0)。 init(n_)：调用初始化函数。 函数解析 1. init(int n_)：初始化 1234void init(int n_) &#123; n = n_; a.assign(n, T&#123;&#125;);&#125; 作用：初始化 Fenwick 树大小 n，并将所有元素清空（设为 T&#123;&#125;，即类型 T 的默认值）。 a.assign(n, T&#123;&#125;)：创建大小为 n 的数组，所有元素初始化为 0（或 T&#123;&#125;）。 2. add(int x, const T &amp;v)：单点更新 12345void add(int x, const T &amp;v) &#123; for (int i = x + 1; i &lt;= n; i += i &amp; -i) &#123; a[i - 1] = a[i - 1] + v; &#125;&#125; 作用：在索引 x 位置加上 v，维护树状数组结构。 核心原理： i = x + 1：树状数组通常从 1 开始存储，因此 x 需要 +1（但 a 仍从 0 开始）。 i += i &amp; -i：跳转到下一个受影响的节点。 a[i - 1] += v：累加 v 到对应位置。 3. sum(int x)：求前缀和 1234567T sum(int x) &#123; T ans&#123;&#125;; for (int i = x; i &gt; 0; i -= i &amp; -i) &#123; ans = ans + a[i - 1]; &#125; return ans;&#125; 作用：计算前缀 [0, x-1] 的区间和。 核心原理： i = x：直接从 x 开始往上累加贡献值。 i -= i &amp; -i：跳转到前一个影响的节点。 ans += a[i - 1]：累加贡献值。 4. rangeSum(int l, int r)：求区间和 123T rangeSum(int l, int r) &#123; return sum(r) - sum(l);&#125; 作用：求 [l, r-1] 区间的和。 计算方式： sum(r) 计算 [0, r-1] 的前缀和。 sum(l) 计算 [0, l-1] 的前缀和。 区间和 = sum(r) - sum(l)。 5. select(const T &amp;k)：二分查找满足前缀和 ≤ k 的最大索引 1234567891011int select(const T &amp;k) &#123; int x = 0; T cur&#123;&#125;; for (int i = 1 &lt;&lt; int(std::log2(n)); i; i /= 2) &#123; if (x + i &lt;= n &amp;&amp; cur + a[x + i - 1] &lt;= k) &#123; x += i; cur = cur + a[x - 1]; &#125; &#125; return x;&#125; 作用：找到最大的 x，使得 sum(x) ≤ k。 核心思路： 使用 倍增思想，从最高位开始尝试加 i，找到最大的 x，使得 sum(x) ≤ k。 i = 1 &lt;&lt; int(std::log2(n))：找最高位的 1。 x + i &lt;= n &amp;&amp; cur + a[x + i - 1] &lt;= k： 如果当前累加不会超过 k，就把 x 更新到 x + i。 cur = cur + a[x - 1]：更新累加值。 用法示例 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; Fenwick&lt;int&gt; fen(10); // 创建大小为 10 的树状数组 // 在索引 2, 4, 6 位置增加值 fen.add(2, 5); fen.add(4, 3); fen.add(6, 7); // 计算前缀和 std::cout &lt;&lt; &quot;sum(6) = &quot; &lt;&lt; fen.sum(6) &lt;&lt; &quot;\\n&quot;; // sum(6) = 5 + 3 + 7 = 15 std::cout &lt;&lt; &quot;sum(3) = &quot; &lt;&lt; fen.sum(3) &lt;&lt; &quot;\\n&quot;; // sum(3) = 5 std::cout &lt;&lt; &quot;rangeSum(2, 6) = &quot; &lt;&lt; fen.rangeSum(2, 6) &lt;&lt; &quot;\\n&quot;; // sum(6) - sum(2) // 选择满足前缀和 &lt;= 8 的最大索引 std::cout &lt;&lt; &quot;select(8) = &quot; &lt;&lt; fen.select(8) &lt;&lt; &quot;\\n&quot;; return 0;&#125; 总结 函数 作用 init(n_) 初始化树状数组，大小为 n_ add(x, v) 在索引 x 位置加上 v sum(x) 计算 [0, x-1] 的前缀和 rangeSum(l, r) 计算 [l, r-1] 的区间和 select(k) 找到最大的 x，使得 sum(x) ≤ k 这个 Fenwick 树适用于： 动态维护数组前缀和（支持修改） 高效计算区间和（O(log n) 复杂度） 二分查找前缀和（select(k)） 适合用于 动态前缀和查询、区间查询、逆序对计算 等场景。","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"https://441135118wz.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"现阶段训练方向","slug":"现阶段训练方向","date":"2025-01-29T14:52:41.000Z","updated":"2025-01-29T15:03:01.751Z","comments":true,"path":"2025/01/29/现阶段训练方向/","permalink":"https://441135118wz.github.io/2025/01/29/%E7%8E%B0%E9%98%B6%E6%AE%B5%E8%AE%AD%E7%BB%83%E6%96%B9%E5%90%91/","excerpt":"1.27的2024年除夕前最后一场div1+div2成功打上了1600分，正式进入蓝名的阶段，接下来是我对新的一年的布局规划和训练目标。","text":"1.27的2024年除夕前最后一场div1+div2成功打上了1600分，正式进入蓝名的阶段，接下来是我对新的一年的布局规划和训练目标。 以前感觉1600分很难打，现在感觉就是把水题快点过掉就能上，但对自身的认知更加清晰，算法部分是相当的弱，树上的题很多想的出来但是实现有困难而且不会调，虽然去年上半年也是这个情况，省赛那道题也是一样，只是之前的基础实在薄弱，我花了将近一年的时间把基础打好，说出来也是自行惭愧，但是去年确实很摆。 但至少能证明我的基础比以前好了许多，30分钟内abc应该是没有问题，剩下的1个小时，如果会做的话，时间应该是够写代码的，所以现阶段已经是能力不足的时期，对2000分左右难度的题的算法了解不够或是早就遗忘，所以我打算在寒假阶段，尽量多利用整块的时间，来学习新的算法，多学习树、图、数据结构等相对较繁琐的知识点。 今天先不定具体算法，感觉树上的问题需要锻炼相关问题的思维，而并不是简单的学一些算法就有用，就像前几天的牛客，我会合并但是换根的时候就宕机推式子推了半天没有结果。需要多做相关题目，最近就去板刷cf树的题试试，先试15道吧。","categories":[],"tags":[]},{"title":"abc390","slug":"abc390","date":"2025-01-25T18:11:33.000Z","updated":"2025-01-25T18:16:45.639Z","comments":true,"path":"2025/01/26/abc390/","permalink":"https://441135118wz.github.io/2025/01/26/abc390/","excerpt":"","text":"10多分钟写完了abc，d的优化不够到位被卡，ddl上又多一条dfs优化了。 这次的e倒是很简单，看到min 取max ，第一反应就是二分，于是就是对三种不同的分别背包然后二分，由于他数据范围小所以暴力n2也能过，但是二分应该是最好的算法。 暴力的思想需要学习。 xor的性质也不是很了解，需要学习线性基。","categories":[],"tags":[]},{"title":"树形dp学习笔记","slug":"树形dp学习笔记","date":"2025-01-24T08:04:09.000Z","updated":"2025-01-25T18:16:27.713Z","comments":true,"path":"2025/01/24/树形dp学习笔记/","permalink":"https://441135118wz.github.io/2025/01/24/%E6%A0%91%E5%BD%A2dp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"牛客寒假训练营i题是个树形dp，又想到济南的铜牌题也是树形dp，感觉有必要研究一下。 update at 1.26 2:00 研究了差不多一天半，差不多会了，先算子树合并的贡献，再算具体的贡献。后面有空细细记录一下。","categories":[],"tags":[]},{"title":"st表模板","slug":"st表模板","date":"2025-01-24T07:33:18.000Z","updated":"2025-01-24T07:42:07.436Z","comments":true,"path":"2025/01/24/st表模板/","permalink":"https://441135118wz.github.io/2025/01/24/st%E8%A1%A8%E6%A8%A1%E6%9D%BF/","excerpt":"简洁好用的st表板子 适用条件：数组不变 如果需要修改，还是写线段树吧","text":"简洁好用的st表板子 适用条件：数组不变 如果需要修改，还是写线段树吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt;class ST&#123;public: const int n; vector&lt;vector&lt;T&gt;&gt; st; ST(int n = 0, vector&lt;T&gt; &amp;a = &#123;&#125;) : n(n)&#123; st = vector(n + 1, vector&lt;T&gt;(22 + 1)); build(n, a); &#125; inline T get(const T &amp;x, const T &amp;y)&#123; return max(x, y); &#125; void build(int n, vector&lt;T&gt; &amp;a)&#123; for(int i = 1; i &lt;= n; i++)&#123; st[i][0] = a[i]; &#125; for(int j = 1, t = 2; t &lt;= n; j++, t &lt;&lt;= 1)&#123; for(int i = 1; i &lt;= n; i++)&#123; if(i + t - 1 &gt; n) break; st[i][j] = get(st[i][j - 1], st[i + (t &gt;&gt; 1)][j - 1]); &#125; &#125; &#125; inline T find(int l, int r)&#123; int t = log(r - l + 1) / log(2); return get(st[l][t], st[r - (1 &lt;&lt; t) + 1][t]); &#125;&#125;;int main() &#123; int n,q; cin &gt;&gt; n &gt;&gt; q; vector&lt;int&gt; f(n + 1); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; f[i]; &#125; ST&lt;int&gt; st(n,f); while (q--) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt;st.find(l,r) &lt;&lt; endl; &#125;&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"https://441135118wz.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"1.24随笔","slug":"1.24随笔","date":"2025-01-23T18:23:12.000Z","updated":"2025-01-23T18:26:27.152Z","comments":true,"path":"2025/01/24/1.24随笔/","permalink":"https://441135118wz.github.io/2025/01/24/1.24%E9%9A%8F%E7%AC%94/","excerpt":"","text":"找回这个荒废了一年多的博客并设置好了，看看效果，后面的做题记录就写在这里了。","categories":[],"tags":[{"name":"日记","slug":"日记","permalink":"https://441135118wz.github.io/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"01-Trie的原理与应用","slug":"01-trie的原理与应用","date":"2023-11-15T06:08:15.000Z","updated":"2025-01-23T18:32:01.194Z","comments":true,"path":"2023/11/15/01-trie的原理与应用/","permalink":"https://441135118wz.github.io/2023/11/15/01-trie%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/","excerpt":"CF1895D这道题用到了01-Trie，那就再来复习一下01-Trie。","text":"CF1895D这道题用到了01-Trie，那就再来复习一下01-Trie。 简介 01-Trie 中文名 是01字典树 ，是一种特殊的字典树，它的字符集只有\\(\\{0,1\\}\\)，主要用来解决一些异或问题。 背景 所以，我们先来看一下字典树。 应用： 1.检索字符串 字典树最基础的应用——查找一个字符串是否在「字典」中出现过。（ps:最容易理解） 2.AC 自动机 trie 是 AC 自动机 的一部分。（先不学） 3.维护异或极值 将数的二进制表示看做一个字符串，就可以建出字符集为\\(\\{0,1\\}\\)的 Trie 树。 4.维护异或和 01-trie 是指字符集为\\(\\{0,1\\}\\)的 trie。01-trie 可以用来维护一些数字的异或和，支持修改（删除 + 重新插入），和全局加一（即：让其所维护所有数值递增 1，本质上是一种特殊的修改操作）。 如果要维护异或和，需要按值从低位到高位建立 trie。 重点来研究一下3两点。 正文 问题引入 给一个长为 \\(n\\) 的数列，要求一个\\(a_i,a_j\\)，使得\\(a_i\\ xor\\ a_j\\)最大。 题解 重点是解决已知\\(a_i\\)，如何找到异或和最大的\\(a_j\\) 我们先建一个01-Trie img 现在对于上面问题，我们贪心地解决即可。如果我们要找与给定数异或最大的数，就尽可能走与该数当前位不同的路径。反之则尽可能走与当前位相同的路径。 这样可以在$n $的复杂度下求出极值。 总结 思想就是这些，代码难度也一般。 在今后遇到异或求极值的时候或是求字符串前缀、是否出现等问题的时候，trie是一个很不错的选择。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://441135118wz.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"推白色相簿2有感","slug":"推白色相簿2有感","date":"2023-11-10T10:47:03.000Z","updated":"2023-11-10T11:41:36.000Z","comments":true,"path":"2023/11/10/推白色相簿2有感/","permalink":"https://441135118wz.github.io/2023/11/10/%E6%8E%A8%E7%99%BD%E8%89%B2%E7%9B%B8%E7%B0%BF2%E6%9C%89%E6%84%9F/","excerpt":"一月份下载的游戏，到了11月10号才推完，断断续续快一年，才推完这部被称为神作的gal。 真正好的作品，是能够打动人心的。","text":"一月份下载的游戏，到了11月10号才推完，断断续续快一年，才推完这部被称为神作的gal。 真正好的作品，是能够打动人心的。 ​ 在推的过程中，不知道为什么，总是感觉到希望伴随着失望。序章没有选项，只能由着“我“选择小木曾雪菜，但是却念念不忘和纱，却在最后快要分开的时候才表露自己的心意。对于序章的结局，我感觉很难以接受，因为剧情里的每个人都是痛苦的。在推的过程中，我时常会想，为什么看似每一步都是最优解，而最终的结局确实这样的痛苦。要比喻一下的话，就很像贪心和dp的区别。我总是会很疑惑，为何雪菜什么都知道，却还是这样爱着春希。即使，中间那被冷落的3年。只有到了最后，我才知道，是她觉得从和纱的手中抢走春希的行为，是最大的罪孽，她此后受到的冷落，都被她理解为了是处罚。而春希，我觉得是最幸福却是最不幸的，他爱着和纱，却不得不选择雪菜，而最后，他的选择是一直喜欢和纱，爱着雪菜。我对于白月光的执着，让我在选项中都向着和纱，但是最后的结局还是有一些遗憾：雪菜和春希走到了最后，和纱也重新振作了起来。看起来还不错的结局，却是经历了多少的挫折和痛苦、猜疑才达成的。三个人永远在一起的世界，也许是永远达不成的，但是，却是每个人为之努力的方向。这样纯真的感情也许只有在这种虚拟的作品中才能见到，但是我们会为之感动，会尽可能的用自己的感性的判断来让他们达成尽可能好的结局。这才是gal的魅力吧。 ​ 和纱之所以努力的练钢琴，有2个原因，一个是爱春希，一个是爱母亲，作品中爱的力量驱使着和纱化悲痛为力量，一直朝前，努力称为下一个天才冬马。 ​ 玩完之后的彷徨，一是因为我对这剧情的感慨，二也是我对感情这种复杂东西的新认知，在之前，我会认为只要努力的付出，像春希一样的思考问题并去付诸行动，便能成功。这部作品，确实对于我没谈过恋爱的人生有指导意义。 ​ 上次这么深思还是玩完eden的时候，也emo了好久，可能是我比较感性，也可能是我的阅历太少了。 以上，便是我推完白色相簿2的一些感受。","categories":[],"tags":[{"name":"颓","slug":"颓","permalink":"https://441135118wz.github.io/tags/%E9%A2%93/"}]},{"title":"拓展欧几里得","slug":"拓展欧几里得","date":"2023-10-18T09:43:53.000Z","updated":"2025-01-24T06:11:29.992Z","comments":true,"path":"2023/10/18/拓展欧几里得/","permalink":"https://441135118wz.github.io/2023/10/18/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"一个晚上的成果。","text":"一个晚上的成果。 背景 贝祖定理： 如果 \\(a\\)、\\(b\\) 是整数，那么一定存在整数 \\(x\\) ， \\(y\\) 使得 \\(ax+by=gcd(a,b)\\) 。 证明： 若任何一个等于 \\(0\\) ，则 \\(gcd(a,b)=a\\) ，这时定理显然成立 若 \\(a,b\\) 不等于0. 由于 \\(gcd(a,b)=gcd(a,-b)\\) , 不妨设 \\(a,b\\) 都大于0， \\(a\\ge b,gcd(a,b)=d.\\) 对 \\(ax+by=d\\) ，两边同时除以 \\(d\\) ,可得 \\(a_1x+b_1y=1\\) ,其中 \\((a_1,b_1)=1\\) . 转证 \\(a_1x+b_1y=1\\) . 我们先回顾一下辗转相除法是怎么做的，由 \\(gcd(a,b)\\longrightarrow gcd(b,a mod b)\\longrightarrow...\\) 我们把模出来的数据叫做 \\(r\\) 于是有： \\[ gcd(a_1,b_1)=gcd(b_1,r_1)=gcd(r_1,r_2)=...=gcd(r_{n-1},r_n)=1 \\] 把辗转相除法中的运算展开，做成带余数的除法，得 \\[ \\begin{equation} \\begin{aligned} a_1=q_1b_1+r_1(0\\le r_1 &lt;b_1) \\\\ b_1=q_2r_1+r_2(0\\le r_2 &lt;r_1) \\\\ r_1=q_3r_2+r_3 (0\\le r_3 &lt;b_2)\\\\ ... \\\\ r_{n-3}=q_{n-1}r_{n-2}+r_{n-1} \\\\ r_{n-2}=q_nr_{n-1}+r_n\\\\ r_{n-1}=q_{n+1}r_{n} \\end{aligned} \\end{equation} \\] 不妨令辗转相除法在除到互质的时候退出则\\(r_n=1\\) （\\(q\\)被换成了\\(x\\),为了符合最终形式） \\[ r_{n-2}=x_nr_{n-1}+1 \\] 即 \\[ 1=r_{n-2}-x_nr_{n-1} \\] 由倒数第三个式子\\(r_{n-1}=r_{n-3}-x_{n-1}r_{n-2}\\)代入上式，得 \\[ 1=(1+x_nx_{n-1})r_{n-2}-x_nr_{n-3} \\] 然后用同样的方法用它上面的等式逐个的消去\\(r_{n-2},...,r_1\\), 可证得\\(1=a_1x+b_1y\\).这样等于是一般式中\\(d=1\\)的情况 欧几里得算法 即辗转相除法，它的代码非常简单： 12345678//辗转相除法，求两个数的最大公因数int gcd(int a, int b)&#123; if (b == 0) return a; else return gcd(b, a%b);&#125; 拓展欧几里得算法 扩展欧几里得算法用来解决这样一个问题：给定两个非零的整数\\(a\\)和\\(b\\)，求一组整数解\\((x，y)\\)使得\\(ax+by = gcd(a,b)\\)成立，其中\\(gcd(a,b)\\)表示\\(a\\)和\\(b\\)的最大公约数。（其中我们通过前面的贝祖定理可知解一定存在） 回忆我们知道的欧几里得算法，它总是把\\(gcd(a,b)\\)转化为求解 \\(gcd(b,a\\%b)\\) ，而当\\(b\\)变为\\(0\\)时返回\\(a\\)，此时的\\(a\\)就等于\\(gcd\\)。也就是说，欧几里得算法结束时变量\\(a\\)中存放的是\\(gcd\\)，变量\\(b\\)中存放的是\\(0\\)，因此此时显然有\\(a × 1 + b × 0 = g c d\\)成立，此时有\\(x=1\\)、\\(y=0\\)成立。 我们不妨利用上面的欧几里得算法的过程来计算\\(x\\)和\\(y\\)。目前已知的是递归边界成立时为\\(x=1\\)、\\(y=0\\)，需要想办法反推出最初始的\\(x\\)和\\(y\\)。 对比等号左右两边可以马上得到下面的递推公式： \\[ \\begin{cases}x_1=y_2\\\\y_1=x_2-(a/b)y_2\\end{cases} \\] 由此可以通过\\(x_2\\)和\\(y_2\\)来进行反推出\\(x_1\\)和\\(y_1\\)了。代码如下： 123456789101112131415int exGcd(int a, int b, int &amp;x, int &amp;y) //x和y使用引用&#123; if(b == 0) &#123; x = 1; y = 0; return a; &#125; int g = exGcd(b, a%b, x, y); //递归计算exGcd（b,a%b） int temp = x; //存放x的值 x = y; y = temp - (a/b)*y; //更新y = x(old) - a/b*y(old) return g; //g是gcd&#125; 由于这里我们使用了引用，因此当 \\(exGcd\\) 函数结束时 \\(x\\) 和 \\(y\\) 就是所求的解。 显然，在得到这样一组解之后，就可以通过下面的式子得到全部解（其中 \\(K\\) 为任意整数）： \\[ \\begin{cases}x^{&#39;}=x+\\frac {b}{gcd}\\times K\\\\y^{&#39;}=y-\\frac {a}{gcd}\\times K\\end{cases} \\]","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"https://441135118wz.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"日记","slug":"日记","permalink":"https://441135118wz.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"name":"算法","slug":"算法","permalink":"https://441135118wz.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"颓","slug":"颓","permalink":"https://441135118wz.github.io/tags/%E9%A2%93/"}]}